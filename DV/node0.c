#include <stdio.h>extern struct rtpkt {  int sourceid;       /* id of sending router sending this pkt */  int destid;         /* id of router to which pkt being sent                          (must be an immediate neighbor) */  int mincost[4];    /* min cost to node 0 ... 3 */};extern int TRACE;extern int YES;extern int NO;extern float clocktime;struct distance_table {  int costs[4][4];} dt0;/* students to write the following two routines, and maybe some others */int linkcost01=1;int linkcost02=3;int linkcost03=7;int min3(int a,int b,int c){    int min=(a<b)?a:b;    return (min<c)?min:c;}int min2(int a,int b){    return (a<b)?a:b;}void rtinit0() { dt0.costs[0][0]=0; dt0.costs[0][1]=1; dt0.costs[0][2]=3; dt0.costs[0][3]=7; dt0.costs[1][0]=999; dt0.costs[1][1]=999; dt0.costs[1][2]=999; dt0.costs[1][3]=999; dt0.costs[2][0]=999; dt0.costs[2][1]=999; dt0.costs[2][2]=999; dt0.costs[2][3]=999; dt0.costs[3][0]=999; dt0.costs[3][1]=999; dt0.costs[3][2]=999; dt0.costs[3][3]=999;  //For each neighbor 1,2,3//Create a routing packet rtpktstruct rtpkt rtpkt0;struct rtpkt * initrtpkt;initrtpkt=&rtpkt0;//Setup the corresponding fields and Send the packetscreatertpkt( initrtpkt, 0, 1, dt0.costs[0]);tolayer2(rtpkt0);creatertpkt( initrtpkt, 0, 2, dt0.costs[0]);tolayer2(rtpkt0);creatertpkt( initrtpkt, 0, 3, dt0.costs[0]);tolayer2(rtpkt0);}void rtupdate0(rcvdpkt)  struct rtpkt *rcvdpkt;{ //update DT //receive DV dt0.costs[rcvdpkt->sourceid][0]=rcvdpkt->mincost[0]; dt0.costs[rcvdpkt->sourceid][1]=rcvdpkt->mincost[1]; dt0.costs[rcvdpkt->sourceid][2]=rcvdpkt->mincost[2]; dt0.costs[rcvdpkt->sourceid][3]=rcvdpkt->mincost[3];  //update own DV int change=0; int update[4]; update[0]=0; update[1]=min3(linkcost01+dt0.costs[1][1],linkcost02+dt0.costs[2][1],linkcost03+dt0.costs[3][1]); update[2]=min3(linkcost01+dt0.costs[1][2],linkcost02+dt0.costs[2][2],linkcost03+dt0.costs[3][2]); update[3]=min3(linkcost01+dt0.costs[1][3],linkcost02+dt0.costs[2][3],linkcost03+dt0.costs[3][3]); int i; for(i=0;i<4;i++) {  if(dt0.costs[0][i]!=update[i])change=1;  dt0.costs[0][i]=update[i]; }  //mincost change? notification if(change==1) { //For each neighbor 1,2,3    //Create a routing packet rtpkt    struct rtpkt rtpkt0;    struct rtpkt * initrtpkt;    initrtpkt=&rtpkt0;        //Setup the corresponding fields and Send the packets    creatertpkt( initrtpkt, 0, 1, dt0.costs[0]);    tolayer2(rtpkt0);    printf("\nDV0 sent to node1, contents: %3d %3d %3d %3d\n",               initrtpkt->mincost[0], initrtpkt->mincost[1],              initrtpkt->mincost[2], initrtpkt->mincost[3]);    creatertpkt( initrtpkt, 0, 2, dt0.costs[0]);    tolayer2(rtpkt0);    printf("DV0 sent to node2, contents: %3d %3d %3d %3d\n",               initrtpkt->mincost[0], initrtpkt->mincost[1],              initrtpkt->mincost[2], initrtpkt->mincost[3]);    creatertpkt( initrtpkt, 0, 3, dt0.costs[0]);    tolayer2(rtpkt0);    printf("DV0 sent to node3, contents: %3d %3d %3d %3d\n\n",               initrtpkt->mincost[0], initrtpkt->mincost[1],              initrtpkt->mincost[2], initrtpkt->mincost[3]);  }     //printout DT     struct distance_table *dtptr;     dtptr=&dt0;     printdt0(dtptr);}printdt0(dtptr)  struct distance_table *dtptr;  {  printf("                dest     \n");  printf("   D0 |    0    1     2    3 \n");  printf("  ----|----------------------\n");  printf("     0|  %3d  %3d   %3d  %3d\n",dtptr->costs[0][0],dtptr->costs[0][1],	 dtptr->costs[0][2],dtptr->costs[0][3]);  printf("via  1|  %3d  %3d   %3d  %3d\n",dtptr->costs[1][0],dtptr->costs[1][1],	 dtptr->costs[1][2],dtptr->costs[1][3]);  printf("     2|  %3d  %3d   %3d  %3d\n",dtptr->costs[2][0],dtptr->costs[2][1],	 dtptr->costs[2][2],dtptr->costs[2][3]);  printf("     3|  %3d  %3d   %3d  %3d\n\n",dtptr->costs[3][0],dtptr->costs[3][1],	 dtptr->costs[3][2],dtptr->costs[3][3]);}linkhandler0(linkid, newcost)     int linkid, newcost;/* called when cost from 0 to linkid changes from current value to newcost*//* You can leave this routine empty if you're an undergrad. If you want *//* to use this routine, you'll need to change the value of the LINKCHANGE *//* constant definition in prog3.c from 0 to 1 */	{    if(linkid==1)    {         linkcost01=newcost;         //update own DV         int change=0;         int update[4];         update[0]=0;         update[1]=min3(linkcost01+dt0.costs[1][1],linkcost02+dt0.costs[2][1],linkcost03+dt0.costs[3][1]);         update[2]=min3(linkcost01+dt0.costs[1][2],linkcost02+dt0.costs[2][2],linkcost03+dt0.costs[3][2]);         update[3]=min3(linkcost01+dt0.costs[1][3],linkcost02+dt0.costs[2][3],linkcost03+dt0.costs[3][3]);         int i;         for(i=0;i<4;i++)         {          if(dt0.costs[0][i]!=update[i])change=1;          dt0.costs[0][i]=update[i];         }                  //mincost change? notification         if(change==1)         {         //For each neighbor 1,2,3            //Create a routing packet rtpkt            struct rtpkt rtpkt0;            struct rtpkt * initrtpkt;            initrtpkt=&rtpkt0;                        //Setup the corresponding fields and Send the packets            creatertpkt( initrtpkt, 0, 1, dt0.costs[0]);            tolayer2(rtpkt0);            printf("\nDV0 sent to node1, contents: %3d %3d %3d %3d\n",                       initrtpkt->mincost[0], initrtpkt->mincost[1],                      initrtpkt->mincost[2], initrtpkt->mincost[3]);            creatertpkt( initrtpkt, 0, 2, dt0.costs[0]);            tolayer2(rtpkt0);            printf("DV0 sent to node2, contents: %3d %3d %3d %3d\n",                       initrtpkt->mincost[0], initrtpkt->mincost[1],                      initrtpkt->mincost[2], initrtpkt->mincost[3]);            creatertpkt( initrtpkt, 0, 3, dt0.costs[0]);            tolayer2(rtpkt0);            printf("DV0 sent to node3, contents: %3d %3d %3d %3d\n\n",                       initrtpkt->mincost[0], initrtpkt->mincost[1],                      initrtpkt->mincost[2], initrtpkt->mincost[3]);          }             //printout DT             struct distance_table *dtptr;             dtptr=&dt0;             printdt0(dtptr);     }}